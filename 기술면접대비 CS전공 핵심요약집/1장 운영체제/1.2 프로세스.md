## 1.2 프로세스  

### 1.2.1 프로세스와 스레드  

#### 프로세스  
  프로세스는 컴퓨터에서 실행 중인 하나의 프로그램을 의미  
  OS는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리로 로드  
  프로세스는 OS로부터 독립된 메모리 영역( 코드, 데이터, 스택, 힙 )을 할당받으며, 다른 프로세스의 메모리 영역에 접근할 수 없음  

  * 스택  
  지역 변수, 함수의 매개변수, 반환되는 주소 값 등이 저장되는 영역  
  높은 주소 값에서 낮은 주소 값으로 메모리가 할당되며, 영역 크기는 컴파일 때 결정  
  * 힙  
  사용자에 의해 동적 메모리 할당이 일어나는 영역  
  낮은 주소 값에서 높은 주소 값으로 메모리가 할당되며, 영역 크기는 런타임 때 결정  
  * 데이터  
  전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역  
  데이터 영역은 세부적으로 BSS 영역과 데이터 영역으로 다시 나눌 수 있음  
  BSS 영역은 초기화하지 않은 변수를, 데이터 영역은 초기화한 변수를 저장  
  * 코드  
  실행할 코드가 기계어로 컴파일되어 저장되는 영역  

  스택 영역과 힙 영역은 메모리 영역을 공유하기 때문에 서로의 영역을 침범하는 문제가 생길 수 있음  
  스택 영역이 힙 영역을 침범하는 스택 오버플로  
  힙 영역이 스택 영역을 침범하는 힙 오버플로  

  #### 스레드  
    프로세스는 한 개 이상의 스레드를 갖는데, 스레드는 프로세스에서 실제로 실행되는 흐름의 단위  
    스레드는 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용하고 지역 변수를 저장하는 스택 영역을 할당  
    전역 변수를 저장하는 힙 영역은 다른 스레드와 공유  

### 1.2.2 PCB
  OS는 프로세스를 제어하기 위해 프로세스 정보를 저장하는데 이를 PCB라고 함  
  PCB는 프로세스의 현재 상태, 프로세스를 나타내는 고유의 PID, 다음 실행할 명령어의 주소인 PC, 프로세스의 우선순위, 메모리 제한 등을 저장  

### 1.2.3 프로세스의 생성  
  새로운 프로세스는 기존 프로세스에서 fork()  함수를 호출해 생성  
  fork() 함수에는 함수를 호출한 프로세스를 복사하는 기능이 있음  
  부모 프로세스에서 fork() 함수를 호출하면 부모 프로세스는 자식 프로세스의 PID 값을, 자식 프로세스는 0을 반환

### 1.2.4 프로세스 상태도  
  모든 프로세는 CPU에 의해 생성되고 소멸하는 과정을 거침  
  프로세스는 생성, 준비, 대기, 실행, 종료라는 5가지 상태로 존재  

  * 생성  
  프로세스가 PCB를 가지고 있지만 OS로부터 승인 받기 전  
  * 준비  
  OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다림  
  * 실행  
  프로세스가 CPU를 할당받아 실행함  
  * 대기  
  프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림  
  * 종료  
  프로세스 실행을 종료함  

  프로세스는 한 상태에서 다른 상태로 다음과 같이 변화  

  * 생성 -> 준비  
  생성 상태의 프로세스가 OS로부터 승인을 받아, 준비 상태의 프로세스가 모여 있는 자료구조인 준비 큐에 추가됨  
  * 준비 -> 실행  
  준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치되어 실행됨  
  * 실행 -> 준비  
  CPU 독점을 방지하기 위해 타임아웃되어 준비 상태로 변경됨  
  * 실행 -> 대기  
  입출력 또는 이벤트 때문에 대기 상태로 변경됨  
  * 대기 -> 준비  
  입출력 또는 이벤트가 완료되어 준비 상태로 변경됨  
  * 실행 -> 종료  
  실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨  

### 1.2.5 멀티 프로세스와 멀티 스레드  
  
  * 동시성  
  하나의 코어( 싱글 코어 )에서 여러 작업을 번갈아 가면서 처리하는 방식  
  하나의 CPU에서 여러 작업을 번갈아 가면서 처리하기 위해 처리 중인 작업을 교체하는 것을 **콘텍스트 스위칭**이라고 함  
  * 병렬성  
  CPU가 여러 개( 멀티 코어 ) 있어서 각 CPU에서 각 작업을 동시에 처리하는 방식  
  물리적인 시간 관점에서 동시에 여러 작업이 처리  

#### 멀티 프로세스  
  **멀티 프로세스**는 응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미  
  응용 프로그램을 프로세스 하나로 구성하는 것보다 여러 개로 구성하는 것이 안정적  
  시간과 메모리 공간을 많이 사용한다는 단점  
  CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체하면서 시간과 메모리가 필요한데, 이를 **오버헤드**라고 함  
  프로세스는 독립적인 메모리를 할당받는데, 프로세스 간에 공유할 자원이 있다면 **IPC**를 통해 프로세스 간의 자원을 공유해야 함  

#### 멀티 스레드  
  **멀티 스레드**는 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미  
  멀티 스레드는 스레드 간에 힙, 데이터, 코드 영역을 공유  
  콘텍스트 스위칭할 때 오버헤드가 적게 발생하고 IPC를 사용하지 않아도 되어 멀티 프로세스의 단점을 보완할 수 있음  
  독립적인 메모리 공간을 갖는 프로레스를 여러 개 생성하는 것보다ㅏ 스레드를 여러 개 생성하는 것이 자원을 효율적으로 사용할 수 있음  
  스레드 간 자원 공유가 프로세스 간 자원 공유보다 시스템 처리 비용이 적고 프로그램 응답 시간도 단축됨  

### 1.2.6 콘텍스트 스위칭  
  **인터럽트**는 CPU에서 프로세스를 처리하다가 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것을 의미  
  멀티 프로레스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것이 콘텍스트 스위칭  

### 1.2.7 프로세스 동기화  

#### 경쟁 상태  
  여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우가 있는데, 이때 자원에 접근하는 순서에 따라 결과 값이 달라질 수 있음  
  공유 자원에 동시에 접근해 경쟁하는 상태라고 해서 **경쟁 상태**라고 함  

#### 임계 영역  
  공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역을 **임계 영역**이라고 함  
  임계 영역에서 경쟁 상태가 발생하는 것을 방지하려면 여러 프로세스가 공유 자원에 접근해도 데이터의 일관성이 유지되도록 **프로세스 동기화**를 해야 함  

  * 상호배제 기법  
  어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없음  
  상호배제 기법으로는 뮤텍스와 세마포어가 있음  
  * 진행  
  임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행  
  * 한정된 대기  
  임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않음  

#### 뮤텍스  
  **뮤텍스**는 **락**을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법  
  임계 영역에 접근한 프로세스가 임계 영역에 락을 건다고 해서 **락킹 매커니즘**이라고도 함  
  임계 영역에 접근하지 못한 프로세스는 락을 얻기 위해 기다리는 동안 락이 풀렸는지 반복문을 돌면서 확인하는 **바쁜 대기**의 한 종류인 스핀락  

#### 세마포어  
  세마포어는 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법  
  공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고 해서 **스그널링 메커니즘**이라고 함  

### 1.2.8 교착 상태  
  상호배제 기법 때문에 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태를 **교착 상태**라고 함  

  * 상호배제  
  하나의 공유 자원에 하나의 프로세스만 접근할 수 있음  
  * 점유와 대기  
  프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기  
  * 비선점  
  다른 프로세스에 할당된 자원을 뺏을 수 없음  
  * 환형 대기  
  프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구  

  교착 상태를 막으려면 앞의 4가지 필요 충분 조건 중에서 한 가지를 제거하면 됨  

  * 상호배제 부정  
  여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있게 함  
  * 점유와 대기 부정  
  프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 프로세스 대기를 없앰  
  또는 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 함  
  * 비선점 부정  
  자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납  
  * 환형 대기 부정  
  자원을 선형 순서로 정렬해 고유 번호를 할당  
  각 프로세스에서 요구할 수 있는 번호와 방향을 정해서 한쪽 방향으로만 자원을 요구  

### 1.2.9 스레드 안전  
  **스레드 안전**은 멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러 개가 동시에 접근해도 문제가 없음을 의미  

### 1.2.10 IPC  
  프로세스 간에 자원을 공유하는 방식을 나타냄  

  1. 공유 메모리  
  프로세스 간에 공유 가능한 메모리를 구성해 자원을 공유하는 방식  
  여러 프로세스에서 접근할 수 있으므로 동기화 문제가 발생할 수 있음  
  2. 소켓  
  네트워크 소켓을 이용하는 프로세스 간 통신으로, 외부 시스템과도 이용할 수 있음  
  클라이언트와 서버 구조로 자원을 주고 받음  
  3. 세마포어  
  접근하는 프로세스를 제어해 공유 자원을 관리  
  4. 파이프  
  FIFO 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식  
  파이프는 단방향 통신만 지원하므로 읽기 또는 쓰기 중 하나만 할 수 있음  
  양방향 통신을 하려먼 읽기 파이프와 쓰기 파이프를 각각 생성해야 함  
  5. 메시지 큐  
  FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식  

### 1.2.11 좀비 프로세스와 고아 프로세스  
  자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식 프로세스를 **좀비 프로세스**라고 함  
  좀비 프로세스가 쌓이면 자원이 낭비  
  부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우에 자식 프로세스를 **고아 프로세스**라고 함