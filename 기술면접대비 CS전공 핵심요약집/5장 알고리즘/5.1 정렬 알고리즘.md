## 5.1 정렬 알고리즘  
  정렬 알고리즘은 '비교하는 정렬 알고리즘'과 '비교하지 않는 정렬 알고리즘'으로 구분  
  비교하는 정렬에는 버블 정렬, 선택 정렬, 삽입 정렬, 합병 정렬, 힙 정렬, 퀵 정렬  
  비교하지 않는 정렬에는 개수 정렬, 기수 정렬  

### 5.1.1 버블 정렬  
  비교 기반 정렬 알고리즘은 **버블 정렬**은 양 옆에 위치한 두 값을 비교하면서 크기 순으로 정렬  
  버블 정렬하면 배열의 뒤에서부터 정렬됨  
  배열의 n번째 요소를 정렬하는 데 n-1번을 비교하므로 배열의 모든 요소를 정렬하려면 n( n-1 ) / 2 만큼 연산을 수행해야 함  
  시간 복잡도 O( N^2 ) 소요  
  정렬을 수행하는 데 비교적 느린 편이지만, 별도의 메모리 공간이 필요하지 않음  

### 5.1.2 선택 정렬  
  비교 기반 정렬 알고리즘은 **선택 정렬**은 배열을 순회하면서 배열의 앞에서부터 차례대로 각 인덱스에 들어갈 값을 선택해 위치  
  선택 정렬은 배열을 순회하면서 각 인덱스에 최솟값을 위치시킴  
  배열 전체에 대한 정렬을 완료하려면 n( n-1 ) / 2 번 연산을 수행  
  시간 복잡도 O( N^2 ) 소요  
  버블 정렬과 마찬가지로 수행 시간은 느린 편이지만, 별도의 메모리 공간이 필요하지 않고 구현도 비교적 간단한 편에 속함  

### 5.1.3 삽입 정렬  
  비교 기반 정렬 알고리즘인 **삽입 정렬**은 배열을 앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입하는 방식  
  n( n-1 ) / 2 번 연산을 수행하며 시간 복잡도는 O( N^2 )  

### 5.1.4 합병 정렬  
  비교 기반 정렬 알고리즘인 **합병 정렬**은 재귀를 이용하는 분할 정복 알고리즘  
  분할은 배열을 쪼개는 것이고, 정복은 분할한 배열을 정렬하면서 하나로 합병하는 것을 의미  
  분할을 마친 각 배열은 다시 하나로 합병하면서 정렬을 수행  
  이때 합병하려는 두 배열과, 두 배열을 합친 크기의 빈 배열이 필요  
  합병 정렬의 시간 복잡도는 O( nlogn )으로 수행 시간 면에서 효율적  
  O( n )은 배열이 정렬되는 데 걸리는 시간 복잡도이고, O( logn )은 배열의 분할 또는 합병 시 걸리는 시간 복잡도  

### 5.1.5 퀵 정렬  
  비교 기반 정렬 알고리즘인 **퀵 정렬**은 합병 정렬과 마찬가지로 분할 정복 알고리즘  
  배열에서 **피봇**이라는 특정 값을 선택해 피봇보다 작은 값으로 구성된 배열과 피봇보다 큰 값으로 구성된 배열로 분할해 정렬하는 방식  
  분할은 배열의 크기가 1 이하가 될 때까지 반복해서 수행  
  분할 정복을 기반으로 한 퀵 정렬의 평균적인 시간 복잡도는 O( nlogn ), 최대 O( n^2 )  
  피봇으로 어떤 값을 선택하느냐에 따라 퀵 정렬의 성능이 좌우  

### 5.1.6 힙 정렬  
  비교 기반 정렬 알고리즘인 **힙 정렬**은 최대 힙이나 최소 힙 자료구조를 이용해 정렬을 수행  
  힙 정렬 과정은 크게 배열을 힙으로 만드는 힙 생성 알고리즘 과정과 힙에서 요소를 꺼내 정렬하는 과정으로 나뉨  
  **힙 생성 알고리즘**은 특정 노드의 두 자식 노드 중 우선순위가 더 높은 자식 노드와 위치를 교환하는 방식  
  
  1. 배열을 힙으로 만드는 과정을 수행  
  2. 최대 힙에서 삭제 연산을 이용해 정렬을 수행  

  힙 정렬을 수행하면 시간 복잡도는 O( nlogn )  
  힙 생성 알고리즘을 수행하는 데 O( logn )이, 전체 요소가 n개여서 전체 정렬하는 데 O( nlogn )이 걸림  

### 5.1.7 기수 정렬  
  **기수 정렬**은 비교하지 않는 정렬 알고리즘으로, 낮은 자릿수부터 정렬을 수행  
  십진수에서 각 자릿수에는 0부터 9까지 숫자가 올 수 있음  
  숫자별로 **버킷**이라는 큐를 생성  
  정렬하려는 숫자들을 각 자릿수에 해당하는 숫자를 각각의 버킷에 넣어 정렬하고 이를 자릿수만큼 반복  
  데이터 개수를 n, 최대 자리수를 d라고 할 때 기수 정렬의 시간 복잡도는 O( dn )  
  버킷을 위한 추가 메모리가 필요하고, 정렬할 수 있는 데이터 타입이 한정적  

### 5.1.8 계수 정렬  
  비교하지 않는 정렬 알고리즘인 **계수 정렬**은 이름 그대로 데이터의 개수를 세서 정렬하는 방식  
  정렬하려는 데이터의 개수를 n, 데이터의 최댓값을 k라고 할 때, 계수 정렬의 시간 복잡도는 O( n + k )  
  정렬하려는 데이터가 시간 복잡도에 영향을 끼침  
  데이터 범위만 한 크기의 배열을 생성해야 하므로 추가로 사용하는 메모리 공간이 있음  
  

