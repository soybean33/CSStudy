## 4.1 데이터베이스의 기본  
데이터베이스(DB, DataBase)는 일정한 규칙, 또는 규약을 통해 구조화되어 저장되는 데이터의 모음  
DBMS(DataBase Management System)는 데이터베이스를 제어, 관리하는 통합 시스템  
데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행  
데이터베이스는 실시간 접근과 동시 공유가 가능  
데이터베이스 위에 DBMS가 있고 그 위에 응용 프로그램이 있음  

### 4.1.1 엔터티(entity)
여러 개의 속성을 지닌 명사  
서비스의 요구 사항에 맞춰 속성이 정해짐  

#### 약한 엔터티와 강한 엔터티  
A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔터티이고 B는 강한 엔터티  

### 4.1.2 릴레이션(relation)  
데이터베이스에서 정보를 구분하여 저장하는 기본 단위  
엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리  
릴레이션은 관계형 데이터베이스에서는 **테이블**이라고 하며 NoSQL 데이터베이스에서는 **컬렉션**이라고 함  

#### 테이블과 컬렉션  
관계형 데이터베이스인 MySQL의 구조는 레코드-테이블-데이터베이스, 레코드가 쌓여서 테이블이되고 테이블이 쌓여서 데이터베이스가 됨  
NoSQL 데이터베이스인 MongoDB의 구조는 도큐먼트-컬렉션-데이터베이스  

### 4.1.3 속성(attribute)  
릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보  
서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔터티의 속성이 됨  

### 4.1.4 도메인(domain)  
릴레이션에 포함된 각가의 속성들이 가질 수 있는 값의 집합  

### 4.1.5 필드와 레코드  
데이터베이스에서 필드와 레코드로 구성된 테이블을 만들 수 있음  
행(row) 단위의 데이터를 레코드 혹은 튜플이라고 함  

#### 필드 타입  
필드는 타입을 갖음  

##### 숫자 타입  
TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등이 있음  
|타입|용량(바이트)|최솟값(부호 있음)|최솟값(부호 없음)|최댓값(부호 없음)|최댓값(부호 있음)|
|--|--|--|--|--|--|
|TINYINT|1|-128|0|127|255|
|SMALLINT|2|-32,768|0|32'767|65'535|
|MEDIUMINT|3|-8,388,608|0|8'388'607|16,777,215|
|INT|4|-2,147,483,648|0|2,147,483,647|4,294,967,295|
|BIGINT|8|-2<sup>63</sup>|0|2<sup>63</sup>-1|2<sup>64</sup>-1|

##### 날짜 타입  
DATE, DATETIME, TIMESTAMP  등이 있음  
|타입|용량(바이트)|최솟값|최댓값|비고|
|--|--|--|--|--|
|DATE|3|1000-01-01|9999-12-31|날짜 부분은 있지만 시간 부분은 없음|
|DATETIME|8|1000-01-01 00:00:00|9999-12-31 23:59:59|날짜 및 시간 부분을 모두 포함|
TIMESTAMP|4|1970-01-01 00:00:01|2938-01-19 03:14:07|날짜 및 시간 부분을 모두 포함|

##### 문자 타입  
CHAR, VARCHAR, TEXT, BLOB, ENUM, SET이 있음  
CHAR의 경우 유동적이지 않은 길이를 가진 데이터의 경우에 효율적이며 유동적인 길이를 가진 데이터는 VARCHAR로 저장하는 것이 좋음  
ENUM이나 SET을 쓸 경우 공간적으로 이점을 볼 수 있지만 애플리케이션의 수정에 따라 데이터베이스의 정의한 목록을 수정해야한다는 단점이 있음  
|타입|최소 용량(바이트)|최대 용량(바이트)|비고|
|--|--|--|--|
|CHAR|0|255|레코드를 저장할 때 무조건 선언한 길이 값으로 **고정**해서 저장|
|VARCHAR|0|65,535|레코드를 저장할 때 데이터에 따라 용량을 가변시켜 저장<br>글자에 해당하는 바이트 + 길이기록용 1바이트|
|TEXT|-|-|큰 문자열 저장에 쓰임|
|BLOB|-|-|이미지, 동영상 등 큰 데이터를 저장에 쓰임|
|ENUM|-|-|하나만 선택하는 단일 선택만 가능<br>ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입<br>최대 65,535개의 요소를 넣을 수 있음|
|SET|-|-|여러개 선택 가능<br>비트 단위의 연산을 할 수 있음|최대 64개의 요소를 넣을 수 있음|

### 4.1.6 관계  
데이터베이스에는 여러 개의 테이블이 있고 이러한 테이블은 서로의 관계가 정의되어 있음  

#### 1:1 관계  
1:1 관계는 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어 줌  

#### 1:N 관계  
한 개체가 다른 많은 개체를 포함하는 관계  

#### N:M 관계  
테이블 두 개를 직접적으로 연결해서 구축하지는 않고 1:N, 1:M이라는 관계를 갖는 테이블 두 개로 나눠서 설정  

### 4.1.7 키  
테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치로 **기본키**, **외래키**, **후보키**, **슈퍼키**, **대체키**가 있음  
```
슈퍼키 - 유일성: 중복되지 않음
ㄴ 후보키 - 최소성: 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있음
  ㄴ 기본키
  ㄴ 대체키: 후보키 중에서 기본키로 선택되지 못한 키
```

#### 기본키(PK, Primary Key)
PK 또는 프라이머리키라고 부름  
유일성과 최소성을 만족하는 키  
테이블의 데이터 중 고유하게 존재하는 속성  
* 자연키  
중복된 값들을 제외하며 중복되지 않은 것을 '자연스레' 뽑다가 나오는 키  
자연키는 언젠가는 변하는 속성을 가짐  
* 인조키  
인위적으로 생성한 키  
오라클은 sequence, MySQL은 auto increment
등으로 설정  
자연키와는 대조적으로 변하지 않음  

#### 외래키(FK, Foreign Key)  
다른 테이블의 기본키를 그대로 참조하는 값  
개체와의 관계를 식별하는 데 사용  
외래키는 중복되어도 괜찮음  

#### 후보키(candidate key)  
기본키가 될 수 있는 후보들  
유일성과 최소성을 동시에 만족  

#### 대체키(alternate key)
후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들  

#### 슈퍼키(super key)
각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키  